
==================== FINAL INTERFACE ====================
2016-03-21 04:32:29.04231 UTC

interface basic_16TlDKVUWlmCxbpaS4ePMT:CTypes 7103
  interface hash: 839b059555154f017e72a510094145ea
  ABI hash: 84c27f45c0785eb998eba8ae5442d85f
  export-list hash: 8219992fa50e53c1d61c71c5120b62ff
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7913ccac713d385024ef983161a252ea
  sig of: Nothing
  used TH splices: False
  where
exports:
  CTypes.cFloatingTypeNames
  CTypes.cSignedTypeNames
  CTypes.cUnsignedTypeBoundsExpQ
  CTypes.cUnsignedTypeNames
module dependencies:
package dependencies: base-4.8.2.0 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 template-haskell-2.10.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Foreign.C.Types dd3b1816f70b1a66f66b78cf01735f8a
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Lib d190351eadb2653e3556255828a98cd8
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax cff7bd12efe5ec99db41a72d8b14d008
b0cbe3d0060f2e7e49078b3955141ef8
  $fEqCFloating :: GHC.Classes.Eq CTypes.CFloating
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CFloating
                  CTypes.$fEqCFloating_$c==
                  CTypes.$fEqCFloating_$c/= -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fEqCFloating_$c/= ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case CTypes.$fEqCFloating_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fEqCFloating_$c== ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: CTypes.CFloating ds1 :: CTypes.CFloating ->
                 case ds of wild {
                   CTypes.IsCFloat a1 a2
                   -> case ds1 of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Integer.Type.eqInteger# ww1 ww4 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Integer.Type.eqInteger# ww2 ww5 of wild4 { DEFAULT ->
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEqFloat_$c==
                                       a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                       b2 `cast` (Foreign.C.Types.NTCo:CFloat[0]) } } } } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.False }
                   CTypes.IsCDouble a1 a2
                   -> case ds1 of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.False
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Integer.Type.eqInteger# ww1 ww4 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Integer.Type.eqInteger# ww2 ww5 of wild4 { DEFAULT ->
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEqDouble_$c==
                                       a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                       b2
                                         `cast`
                                       (Foreign.C.Types.NTCo:CDouble[0]) } } } } } } } }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fEqCSigned :: GHC.Classes.Eq CTypes.CSigned
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CSigned CTypes.$fEqCSigned_$c== CTypes.$fEqCSigned_$c/= -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fEqCSigned_$c/= ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: CTypes.CSigned b :: CTypes.CSigned ->
                 case CTypes.$fEqCSigned_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fEqCSigned_$c== ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: CTypes.CSigned ds1 :: CTypes.CSigned ->
                 case ds of wild {
                   CTypes.IsCChar a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCChar b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt8_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CChar[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CChar[0]) } } }
                   CTypes.IsCSChar a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCSChar b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt8_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CSChar[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CSChar[0]) } } }
                   CTypes.IsCShort a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCShort b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt16_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CShort[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CShort[0]) } } }
                   CTypes.IsCInt a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCInt b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt32_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CInt[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CInt[0]) } } }
                   CTypes.IsCLong a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCLong b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt64_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CLong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CLong[0]) } } }
                   CTypes.IsCWchar a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCWchar b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt32_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CWchar[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CWchar[0]) } } }
                   CTypes.IsCLLong a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCLLong b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Int.$fEqInt64_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CLLong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CLLong[0]) } } } }) -}
9309557dbd03e46019a39e3c28822106
  $fEqCUnsigned :: GHC.Classes.Eq CTypes.CUnsigned
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CUnsigned
                  CTypes.$fEqCUnsigned_$c==
                  CTypes.$fEqCUnsigned_$c/= -}
9309557dbd03e46019a39e3c28822106
  $fEqCUnsigned_$c/= ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: CTypes.CUnsigned b :: CTypes.CUnsigned ->
                 case CTypes.$fEqCUnsigned_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9309557dbd03e46019a39e3c28822106
  $fEqCUnsigned_$c== ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: CTypes.CUnsigned ds1 :: CTypes.CUnsigned ->
                 case ds of wild {
                   CTypes.IsCUChar a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCUChar b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord8_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CUChar[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CUChar[0]) } } }
                   CTypes.IsCUShort a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCUShort b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord16_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CUShort[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CUShort[0]) } } }
                   CTypes.IsCUInt a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCUInt b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord32_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CUInt[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CUInt[0]) } } }
                   CTypes.IsCULong a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCULong b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord64_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CULong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CULong[0]) } } }
                   CTypes.IsCULLong a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CTypes.IsCULLong b1 b2
                        -> case GHC.Integer.Type.eqInteger# a1 b1 of wild2 { DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2 of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Word.$fEqWord64_$c==
                                  a2 `cast` (Foreign.C.Types.NTCo:CULLong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CULLong[0]) } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating :: GHC.Classes.Ord CTypes.CFloating
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CFloating
                  CTypes.$fEqCFloating
                  CTypes.$fOrdCFloating_$ccompare
                  CTypes.$fOrdCFloating_$c<
                  CTypes.$fOrdCFloating_$c<=
                  CTypes.$fOrdCFloating_$c>
                  CTypes.$fOrdCFloating_$c>=
                  CTypes.$fOrdCFloating_$cmax
                  CTypes.$fOrdCFloating_$cmin -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$c< ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case a of wild {
                   CTypes.IsCFloat a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdFloat_$c<
                                  a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                             GHC.Types.GT -> GHC.Types.False } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.True }
                   CTypes.IsCDouble a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.False
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdDouble_$c<
                                  a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                             GHC.Types.GT -> GHC.Types.False } } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$c<= ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case a of wild {
                   CTypes.IsCFloat a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdFloat_$c<=
                                  a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                             GHC.Types.GT -> GHC.Types.False } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.True }
                   CTypes.IsCDouble a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.False
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdDouble_$c<=
                                  a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                             GHC.Types.GT -> GHC.Types.False } } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$c> ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case a of wild {
                   CTypes.IsCFloat a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdFloat_$c>
                                  a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                             GHC.Types.GT -> GHC.Types.True } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.False }
                   CTypes.IsCDouble a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.True
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdDouble_$c>
                                  a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                             GHC.Types.GT -> GHC.Types.True } } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$c>= ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case a of wild {
                   CTypes.IsCFloat a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdFloat_$c>=
                                  a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                             GHC.Types.GT -> GHC.Types.True } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.False }
                   CTypes.IsCDouble a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.True
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdDouble_$c>=
                                  a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                             GHC.Types.GT -> GHC.Types.True } } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$ccompare ::
    CTypes.CFloating -> CTypes.CFloating -> GHC.Types.Ordering
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: CTypes.CFloating b :: CTypes.CFloating ->
                 case a of wild {
                   CTypes.IsCFloat a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdFloat_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CFloat[0])
                             GHC.Types.GT -> GHC.Types.GT } } }
                        CTypes.IsCDouble ipv ipv1 -> GHC.Types.LT }
                   CTypes.IsCDouble a1 a2
                   -> case b of wild1 {
                        CTypes.IsCFloat ipv ipv1 -> GHC.Types.GT
                        CTypes.IsCDouble b1 b2
                        -> case a1 of ww { GHC.Real.:% ww1 ww2 ->
                           case b1 of ww3 { GHC.Real.:% ww4 ww5 ->
                           case GHC.Real.$w$s$ccompare ww1 ww2 ww4 ww5 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Classes.$fOrdDouble_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CDouble[0])
                             GHC.Types.GT -> GHC.Types.GT } } } } }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$cmax ::
    CTypes.CFloating -> CTypes.CFloating -> CTypes.CFloating
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CFloating y :: CTypes.CFloating ->
                 case CTypes.$fOrdCFloating_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fOrdCFloating_$cmin ::
    CTypes.CFloating -> CTypes.CFloating -> CTypes.CFloating
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CFloating y :: CTypes.CFloating ->
                 case CTypes.$fOrdCFloating_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned :: GHC.Classes.Ord CTypes.CSigned
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CSigned
                  CTypes.$fEqCSigned
                  CTypes.$fOrdCSigned_$ccompare
                  CTypes.$fOrdCSigned_$c<
                  CTypes.$fOrdCSigned_$c<=
                  CTypes.$fOrdCSigned_$c>
                  CTypes.$fOrdCSigned_$c>=
                  CTypes.$fOrdCSigned_$cmax
                  CTypes.$fOrdCSigned_$cmin -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$c< ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$c<= ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$c> ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$c>= ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$ccompare ::
    CTypes.CSigned -> CTypes.CSigned -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U> -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$cmax ::
    CTypes.CSigned -> CTypes.CSigned -> CTypes.CSigned
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fOrdCSigned_$cmin ::
    CTypes.CSigned -> CTypes.CSigned -> CTypes.CSigned
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CSigned y :: CTypes.CSigned ->
                 case CTypes.$fOrdCSigned_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned :: GHC.Classes.Ord CTypes.CUnsigned
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CUnsigned
                  CTypes.$fEqCUnsigned
                  CTypes.$fOrdCUnsigned_$ccompare
                  CTypes.$fOrdCUnsigned_$c<
                  CTypes.$fOrdCUnsigned_$c<=
                  CTypes.$fOrdCUnsigned_$c>
                  CTypes.$fOrdCUnsigned_$c>=
                  CTypes.$fOrdCUnsigned_$cmax
                  CTypes.$fOrdCUnsigned_$cmin -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$c< ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$c<= ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$c> ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$c>= ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$ccompare ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ a :: CTypes.CUnsigned b :: CTypes.CUnsigned ->
                 case a of wild {
                   CTypes.IsCUChar a1 a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        CTypes.IsCUChar b1 b2
                        -> case GHC.Integer.Type.compareInteger a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Word.$fOrdWord8_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CUChar[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CUChar[0])
                             GHC.Types.GT -> GHC.Types.GT } }
                   CTypes.IsCUShort a1 a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.LT
                        CTypes.IsCUChar ds ds1 -> GHC.Types.GT
                        CTypes.IsCUShort b1 b2
                        -> case GHC.Integer.Type.compareInteger a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Word.$fOrdWord16_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CUShort[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CUShort[0])
                             GHC.Types.GT -> GHC.Types.GT } }
                   CTypes.IsCUInt a1 a2
                   -> let {
                        $j :: GHC.Prim.Int# -> GHC.Types.Ordering
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ b# :: GHC.Prim.Int#[OneShot] ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># b# 2) of wild1 {
                            GHC.Types.False
                            -> case b of wild2 {
                                 DEFAULT -> GHC.Types.GT
                                 CTypes.IsCUInt b1 b2
                                 -> case GHC.Integer.Type.compareInteger a1 b1 of wild3 {
                                      GHC.Types.LT -> GHC.Types.LT
                                      GHC.Types.EQ
                                      -> GHC.Word.$fOrdWord32_$ccompare
                                           a2 `cast` (Foreign.C.Types.NTCo:CUInt[0])
                                           b2 `cast` (Foreign.C.Types.NTCo:CUInt[0])
                                      GHC.Types.GT -> GHC.Types.GT } }
                            GHC.Types.True -> GHC.Types.LT }
                      } in
                      case b of wild1 {
                        CTypes.IsCUChar ds ds1 -> $j 0
                        CTypes.IsCUShort ds ds1 -> $j 1
                        CTypes.IsCUInt ds ds1 -> $j 2
                        CTypes.IsCULong ds ds1 -> $j 3
                        CTypes.IsCULLong ds ds1 -> $j 4 }
                   CTypes.IsCULong a1 a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        CTypes.IsCULong b1 b2
                        -> case GHC.Integer.Type.compareInteger a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Word.$fOrdWord64_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CULong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CULong[0])
                             GHC.Types.GT -> GHC.Types.GT }
                        CTypes.IsCULLong ds ds1 -> GHC.Types.LT }
                   CTypes.IsCULLong a1 a2
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        CTypes.IsCULLong b1 b2
                        -> case GHC.Integer.Type.compareInteger a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> GHC.Word.$fOrdWord64_$ccompare
                                  a2 `cast` (Foreign.C.Types.NTCo:CULLong[0])
                                  b2 `cast` (Foreign.C.Types.NTCo:CULLong[0])
                             GHC.Types.GT -> GHC.Types.GT } } }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$cmax ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> CTypes.CUnsigned
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
9309557dbd03e46019a39e3c28822106
  $fOrdCUnsigned_$cmin ::
    CTypes.CUnsigned -> CTypes.CUnsigned -> CTypes.CUnsigned
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: CTypes.CUnsigned y :: CTypes.CUnsigned ->
                 case CTypes.$fOrdCUnsigned_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fShowCFloating :: GHC.Show.Show CTypes.CFloating
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CFloating
                  CTypes.$fShowCFloating_$cshowsPrec
                  CTypes.$fShowCFloating_$cshow
                  CTypes.$fShowCFloating_$cshowList -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fShowCFloating1 :: CTypes.CFloating -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: CTypes.CFloating -> CTypes.$w$cshowsPrec 0 w) -}
adfb4687eba6afbadd522b481d23ed3c
  $fShowCFloating2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IsCDouble "#) -}
b0f8e0a2fc2135d48a06d487e7fa82d1
  $fShowCFloating3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IsCFloat "#) -}
0684fa4da74a6021ca22140374e29ad1
  $fShowCFloating4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fShowCFloating_$cshow :: CTypes.CFloating -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: CTypes.CFloating ->
                 CTypes.$fShowCFloating_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fShowCFloating_$cshowList :: [CTypes.CFloating] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ CTypes.CFloating
                   CTypes.$fShowCFloating1) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $fShowCFloating_$cshowsPrec ::
    GHC.Types.Int -> CTypes.CFloating -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: CTypes.CFloating ->
                 case w of ww { GHC.Types.I# ww1 ->
                 CTypes.$w$cshowsPrec ww1 w1 }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fShowCSigned :: GHC.Show.Show CTypes.CSigned
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CSigned
                  CTypes.$fShowCSigned_$cshowsPrec
                  CTypes.$fShowCSigned_$cshow
                  CTypes.$fShowCSigned_$cshowList -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fShowCSigned1 :: CTypes.CSigned -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: CTypes.CSigned w1 :: GHC.Base.String ->
                 CTypes.$w$cshowsPrec1 0 w w1) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fShowCSigned_$cshow :: CTypes.CSigned -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: CTypes.CSigned ->
                 CTypes.$fShowCSigned_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fShowCSigned_$cshowList :: [CTypes.CSigned] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ CTypes.CSigned
                   CTypes.$fShowCSigned1) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $fShowCSigned_$cshowsPrec ::
    GHC.Types.Int -> CTypes.CSigned -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: CTypes.CSigned w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 CTypes.$w$cshowsPrec1 ww1 w1 w2 }) -}
9309557dbd03e46019a39e3c28822106
  $fShowCUnsigned :: GHC.Show.Show CTypes.CUnsigned
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ CTypes.CUnsigned
                  CTypes.$fShowCUnsigned_$cshowsPrec
                  CTypes.$fShowCUnsigned_$cshow
                  CTypes.$fShowCUnsigned_$cshowList -}
9309557dbd03e46019a39e3c28822106
  $fShowCUnsigned1 :: CTypes.CUnsigned -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: CTypes.CUnsigned ->
                 CTypes.$w$cshowsPrec2 0 w) -}
9309557dbd03e46019a39e3c28822106
  $fShowCUnsigned_$cshow :: CTypes.CUnsigned -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: CTypes.CUnsigned ->
                 CTypes.$fShowCUnsigned_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9309557dbd03e46019a39e3c28822106
  $fShowCUnsigned_$cshowList :: [CTypes.CUnsigned] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ CTypes.CUnsigned
                   CTypes.$fShowCUnsigned1) -}
9309557dbd03e46019a39e3c28822106
  $fShowCUnsigned_$cshowsPrec ::
    GHC.Types.Int -> CTypes.CUnsigned -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: CTypes.CUnsigned ->
                 case w of ww { GHC.Types.I# ww1 ->
                 CTypes.$w$cshowsPrec2 ww1 w1 }) -}
b0cbe3d0060f2e7e49078b3955141ef8
  $w$cshowsPrec ::
    GHC.Prim.Int# -> CTypes.CFloating -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: CTypes.CFloating ->
                 case w of wild {
                   CTypes.IsCFloat b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b2
                                 `cast`
                               (UnivCo mkUnsafeCo representational Foreign.C.Types.CFloat GHC.Types.Float) of ww1 { GHC.Types.F# ww2 ->
                          GHC.Float.$w$sshowSignedFloat1
                            GHC.Float.$fShowFloat_$sshowFloat
                            CTypes.$fShowCFloating4
                            ww2 }
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            CTypes.$fShowCFloating3
                            (case b1 of ww2 { GHC.Real.:% ww3 ww4 ->
                             case GHC.Real.$w$s$cshowsPrec
                                    11
                                    ww3
                                    ww4
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g x)) of ww5 { (#,#) ww6 ww7 ->
                             GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   CTypes.IsCDouble b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b2
                                 `cast`
                               (UnivCo mkUnsafeCo representational Foreign.C.Types.CDouble GHC.Types.Double) of ww1 { GHC.Types.D# ww2 ->
                          GHC.Float.$w$sshowSignedFloat
                            GHC.Float.$fShowDouble_$sshowFloat
                            CTypes.$fShowCFloating4
                            ww2 }
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            CTypes.$fShowCFloating2
                            (case b1 of ww2 { GHC.Real.:% ww3 ww4 ->
                             case GHC.Real.$w$s$cshowsPrec
                                    11
                                    ww3
                                    ww4
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g x)) of ww5 { (#,#) ww6 ww7 ->
                             GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) } }) -}
b2e7d90d1c7ccaac755f74e0578799f9
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> CTypes.CSigned -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
9309557dbd03e46019a39e3c28822106
  $w$cshowsPrec2 ::
    GHC.Prim.Int# -> CTypes.CUnsigned -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
b0cbe3d0060f2e7e49078b3955141ef8
  data CFloating
    = IsCFloat GHC.Real.Rational Foreign.C.Types.CFloat
    | IsCDouble GHC.Real.Rational Foreign.C.Types.CDouble
b2e7d90d1c7ccaac755f74e0578799f9
  data CSigned
    = IsCChar GHC.Integer.Type.Integer Foreign.C.Types.CChar
    | IsCSChar GHC.Integer.Type.Integer Foreign.C.Types.CSChar
    | IsCShort GHC.Integer.Type.Integer Foreign.C.Types.CShort
    | IsCInt GHC.Integer.Type.Integer Foreign.C.Types.CInt
    | IsCLong GHC.Integer.Type.Integer Foreign.C.Types.CLong
    | IsCWchar GHC.Integer.Type.Integer Foreign.C.Types.CWchar
    | IsCLLong GHC.Integer.Type.Integer Foreign.C.Types.CLLong
9309557dbd03e46019a39e3c28822106
  data CUnsigned
    = IsCUChar GHC.Integer.Type.Integer Foreign.C.Types.CUChar
    | IsCUShort GHC.Integer.Type.Integer Foreign.C.Types.CUShort
    | IsCUInt GHC.Integer.Type.Integer Foreign.C.Types.CUInt
    | IsCULong GHC.Integer.Type.Integer Foreign.C.Types.CULong
    | IsCULLong GHC.Integer.Type.Integer Foreign.C.Types.CULLong
f94c2427f014ada6122ed6ce52b12e5f
  class SizableCType a where
    sizeCType ::
      (GHC.Classes.Ord b, GHC.Num.Num b) => b -> GHC.Base.Maybe a
0313688f5845a1ade60214ee96ef03ad
  cFloatingTypeNames :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cFloatingTypeNames3
                   CTypes.cFloatingTypeNames1) -}
5b3a052fd6ff89498d161106a4af14d7
  cFloatingTypeNames1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cFloatingTypeNames2
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
fbb6e33ca1681303584be2c4a820d504
  cFloatingTypeNames2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CDouble"#) -}
3901e9f4270aa2dcb7853d50e37896ef
  cFloatingTypeNames3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CFloat"#) -}
7d0557cf4aaf2a3a28b588c25fad4677
  cSignedTypeNames :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames13
                   CTypes.cSignedTypeNames1) -}
05d1b0dd963a68cc4792a31e50ff8170
  cSignedTypeNames1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames12
                   CTypes.cSignedTypeNames2) -}
1d703bb5330ebc373bde298623d6c22c
  cSignedTypeNames10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CInt"#) -}
256bb65b726a86447334a0703e65341a
  cSignedTypeNames11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CShort"#) -}
6b8ce3a119b516190d8f9e71b7fa9368
  cSignedTypeNames12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CSChar"#) -}
53b750bfd17b744a7d5d2cab6fe49545
  cSignedTypeNames13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CChar"#) -}
c7909f209397e4329cc9859f8b3d32bc
  cSignedTypeNames2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames11
                   CTypes.cSignedTypeNames3) -}
86146da93ac92affaeaed11dbedeaa51
  cSignedTypeNames3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames10
                   CTypes.cSignedTypeNames4) -}
6b4af6e8cfb817ab834208612d0c6e02
  cSignedTypeNames4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames9
                   CTypes.cSignedTypeNames5) -}
6e65fad57c75d046056ee477f13b8dc6
  cSignedTypeNames5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames8
                   CTypes.cSignedTypeNames6) -}
7241c79a119b9572684fa5437eda50e9
  cSignedTypeNames6 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cSignedTypeNames7
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
bc358a99a7b695fa347fddbe74f2f32b
  cSignedTypeNames7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLLong"#) -}
1e31aced61cf7f811adef9f8b70188e8
  cSignedTypeNames8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CWchar"#) -}
b6feab07b52d1ec98e01b06fc705d349
  cSignedTypeNames9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLong"#) -}
497c2c73c473cea7764e7863fb20e142
  cUnsignedTypeBoundsExpQ :: Language.Haskell.TH.Lib.ExpQ
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                CTypes.cUnsignedTypeBoundsExpQ1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <Language.Haskell.TH.Syntax.Exp>_N)) -}
67edabc9d00a132f17415cddb5eb0dff
  cUnsignedTypeBoundsExpQ1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.listE1
                   CTypes.cUnsignedTypeBoundsExpQ2) -}
f2ebfffe3795a9e674b600eec56bb4a6
  cUnsignedTypeBoundsExpQ10 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CTypes.cUnsignedTypeBoundsExpQ11
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a870b1213f58f64b5dc1df35ef60c8ee
  cUnsignedTypeBoundsExpQ11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "maxBound"#) -}
699d21fdca5c20cbde52cb614d1f1abf
  cUnsignedTypeBoundsExpQ12 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.global1
                   CTypes.cUnsignedTypeBoundsExpQ13) -}
e43e584ef6c70f5eda1c13bb43a2dc30
  cUnsignedTypeBoundsExpQ13 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CTypes.cUnsignedTypeBoundsExpQ14
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
9614c6e53f60c38098c6214b1a1356ad
  cUnsignedTypeBoundsExpQ14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "minBound"#) -}
11b2a521bd11723eb4244e0a061535ac
  cUnsignedTypeBoundsExpQ15 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Strictness: <S(SLLLLLLLLLLLLLLLL),U(U(U,U,U,U,U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 let {
                   lvl13 :: GHC.Base.Monad m
                   = Language.Haskell.TH.Syntax.$p1Quasi @ m eta
                 } in
                 let {
                   lvl14 :: m Language.Haskell.TH.Syntax.Exp
                   = GHC.Base.return
                       @ m
                       (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                       @ Language.Haskell.TH.Syntax.Exp
                       CTypes.cUnsignedTypeBoundsExpQ19
                 } in
                 let {
                   lvl15 :: m Language.Haskell.TH.Syntax.Exp
                   = GHC.Base.return
                       @ m
                       (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                       @ Language.Haskell.TH.Syntax.Exp
                       CTypes.cUnsignedTypeBoundsExpQ16
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl13
                   @ Language.Haskell.TH.Syntax.Exp
                   @ Language.Haskell.TH.Syntax.Exp
                   (GHC.Base.return
                      @ m
                      lvl13
                      @ Language.Haskell.TH.Syntax.Exp
                      CTypes.cUnsignedTypeBoundsExpQ16)
                   (\ x1 :: Language.Haskell.TH.Syntax.Exp ->
                    let {
                      lvl16 :: GHC.Base.Maybe Language.Haskell.TH.Syntax.Exp
                      = GHC.Base.Just @ Language.Haskell.TH.Syntax.Exp x1
                    } in
                    GHC.Base.>>=
                      @ m
                      lvl13
                      @ Language.Haskell.TH.Syntax.Exp
                      @ Language.Haskell.TH.Syntax.Exp
                      lvl14
                      (\ x2 :: Language.Haskell.TH.Syntax.Exp ->
                       GHC.Base.>>=
                         @ m
                         lvl13
                         @ Language.Haskell.TH.Syntax.Exp
                         @ Language.Haskell.TH.Syntax.Exp
                         lvl15
                         (\ x3 :: Language.Haskell.TH.Syntax.Exp ->
                          GHC.Base.return
                            @ m
                            lvl13
                            @ Language.Haskell.TH.Syntax.Exp
                            (Language.Haskell.TH.Syntax.InfixE
                               lvl16
                               x2
                               (GHC.Base.Just @ Language.Haskell.TH.Syntax.Exp x3)))))) -}
449df0b7dc852075b0130fc3f295d1ff
  cUnsignedTypeBoundsExpQ16 :: Language.Haskell.TH.Syntax.Exp
  {- Unfolding: (Language.Haskell.TH.Syntax.VarE
                   CTypes.cUnsignedTypeBoundsExpQ17) -}
003d5c87b85f8a2fe181e8a34c9e250a
  cUnsignedTypeBoundsExpQ17 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CTypes.cUnsignedTypeBoundsExpQ18
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
432b9327772eb9c7240c50d5f55b10e2
  cUnsignedTypeBoundsExpQ18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "toInteger"#) -}
d0d457e1382db0693688c593b3e5821d
  cUnsignedTypeBoundsExpQ19 :: Language.Haskell.TH.Syntax.Exp
  {- Unfolding: (Language.Haskell.TH.Syntax.VarE
                   CTypes.cUnsignedTypeBoundsExpQ20) -}
7e967231085d09169782f648c6b270b5
  cUnsignedTypeBoundsExpQ2 ::
    [Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp]
  {- Unfolding: (GHC.Base.map
                   @ [GHC.Types.Char]
                   @ (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                   CTypes.cUnsignedTypeBoundsExpQ3
                     `cast`
                   (<GHC.Base.String>_R
                    ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <Language.Haskell.TH.Syntax.Exp>_N))
                   CTypes.cUnsignedTypeNames) -}
a13ba24d06c2640b203f066d5eb54e85
  cUnsignedTypeBoundsExpQ20 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CTypes.cUnsignedTypeBoundsExpQ21
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
7e7546d3428a6228184c5cf004bc0885
  cUnsignedTypeBoundsExpQ21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "***"#) -}
323eb8adb14438173ecc6ab773be5ff9
  cUnsignedTypeBoundsExpQ3 ::
    GHC.Base.String
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Unfolding: (\ t :: GHC.Base.String ->
                 Language.Haskell.TH.Lib.appE1
                   CTypes.cUnsignedTypeBoundsExpQ15
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N))
                   (Language.Haskell.TH.Lib.sigE1
                      CTypes.cUnsignedTypeBoundsExpQ6
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <Language.Haskell.TH.Syntax.Exp>_N))
                      (Language.Haskell.TH.Lib.appT1
                         (Language.Haskell.TH.Lib.appT1
                            CTypes.cUnsignedTypeBoundsExpQ4
                              `cast`
                            (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                      <Language.Haskell.TH.Syntax.Type>_N))
                            (let {
                               x :: Language.Haskell.TH.Syntax.Name
                               = case GHC.List.reverse1
                                        @ GHC.Types.Char
                                        t
                                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                                   []
                                   -> Language.Haskell.TH.Syntax.Name
                                        (GHC.Types.[] @ GHC.Types.Char)
                                          `cast`
                                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                                        Language.Haskell.TH.Syntax.NameS
                                   : ds rev
                                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                                      case ds1 of ds2 {
                                        DEFAULT
                                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                                  wild1
                                                  (GHC.Types.[] @ GHC.Types.Char)
                                                  rev of ww { (#,#) ww1 ww2 ->
                                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                                        '.'
                                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                                  wild1
                                                  (GHC.Types.[] @ GHC.Types.Char)
                                                  rev of ww { (#,#) ww1 ww2 ->
                                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }
                             } in
                             let {
                               lvl13 :: Language.Haskell.TH.Syntax.Type
                               = Language.Haskell.TH.Syntax.ConT x
                             } in
                             (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                              GHC.Base.return
                                @ m
                                (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                                @ Language.Haskell.TH.Syntax.Type
                                lvl13)
                               `cast`
                             (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                       <Language.Haskell.TH.Syntax.Type>_N))))
                           `cast`
                         (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                   <Language.Haskell.TH.Syntax.Type>_N))
                         (let {
                            x :: Language.Haskell.TH.Syntax.Name
                            = case GHC.List.reverse1
                                     @ GHC.Types.Char
                                     t
                                     (GHC.Types.[] @ GHC.Types.Char) of wild {
                                []
                                -> Language.Haskell.TH.Syntax.Name
                                     (GHC.Types.[] @ GHC.Types.Char)
                                       `cast`
                                     (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                                     Language.Haskell.TH.Syntax.NameS
                                : ds rev
                                -> case ds of wild1 { GHC.Types.C# ds1 ->
                                   case ds1 of ds2 {
                                     DEFAULT
                                     -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                               wild1
                                               (GHC.Types.[] @ GHC.Types.Char)
                                               rev of ww { (#,#) ww1 ww2 ->
                                        Language.Haskell.TH.Syntax.Name ww1 ww2 }
                                     '.'
                                     -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                               wild1
                                               (GHC.Types.[] @ GHC.Types.Char)
                                               rev of ww { (#,#) ww1 ww2 ->
                                        Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }
                          } in
                          let {
                            lvl13 :: Language.Haskell.TH.Syntax.Type
                            = Language.Haskell.TH.Syntax.ConT x
                          } in
                          (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                           GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ Language.Haskell.TH.Syntax.Type
                             lvl13)
                            `cast`
                          (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                    <Language.Haskell.TH.Syntax.Type>_N))))
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <Language.Haskell.TH.Syntax.Type>_N)))
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N))) -}
b4d3600aeeeb9b58e810042eb7986669
  cUnsignedTypeBoundsExpQ4 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.TupleT
                      CTypes.cUnsignedTypeBoundsExpQ5)) -}
6e23c9c48acfb72d540eb6076f767ee1
  cUnsignedTypeBoundsExpQ5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2) -}
9ed9d839d777189b77c4bfce02b00733
  cUnsignedTypeBoundsExpQ6 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.tupE1
                   CTypes.cUnsignedTypeBoundsExpQ7) -}
db67ccfa0c74cc1f3f5a2793d0d19936
  cUnsignedTypeBoundsExpQ7 :: [Language.Haskell.TH.Lib.ExpQ]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Lib.ExpQ
                   CTypes.cUnsignedTypeBoundsExpQ12
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N))
                   CTypes.cUnsignedTypeBoundsExpQ8) -}
991c954b1e80e00bd60675c77a707fe4
  cUnsignedTypeBoundsExpQ8 :: [Language.Haskell.TH.Lib.ExpQ]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Lib.ExpQ
                   CTypes.cUnsignedTypeBoundsExpQ9
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.ExpQ)) -}
8747af210be36b3b45600a1d79883413
  cUnsignedTypeBoundsExpQ9 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Exp
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.global1
                   CTypes.cUnsignedTypeBoundsExpQ10) -}
7a617ca6317a738cff5a6c76d2424926
  cUnsignedTypeNames :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cUnsignedTypeNames9
                   CTypes.cUnsignedTypeNames1) -}
f82a801499a19a36b96acaafa856873a
  cUnsignedTypeNames1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cUnsignedTypeNames8
                   CTypes.cUnsignedTypeNames2) -}
d7b92531f18acb35cab88f1e74ccec78
  cUnsignedTypeNames2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cUnsignedTypeNames7
                   CTypes.cUnsignedTypeNames3) -}
3716830629ffd76c8dc21fa8e8b586e8
  cUnsignedTypeNames3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cUnsignedTypeNames6
                   CTypes.cUnsignedTypeNames4) -}
62fc369fc0ac741b2b66f1790391f3eb
  cUnsignedTypeNames4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   CTypes.cUnsignedTypeNames5
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
41f26c2216d780c7c6d426ad2876367b
  cUnsignedTypeNames5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CULLong"#) -}
65441caaa380cf097374ea22165350af
  cUnsignedTypeNames6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CULong"#) -}
c1d55c97d261a9b77f3ef15a5fdf0d3a
  cUnsignedTypeNames7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CUInt"#) -}
6ef4f544d5ee587fca9a11407c2d868a
  cUnsignedTypeNames8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CUShort"#) -}
fe47b2d132fbbac381c1b8e532671391
  cUnsignedTypeNames9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CUChar"#) -}
instance GHC.Classes.Eq [CTypes.CFloating] = CTypes.$fEqCFloating
instance GHC.Classes.Eq [CTypes.CSigned] = CTypes.$fEqCSigned
instance GHC.Classes.Eq [CTypes.CUnsigned] = CTypes.$fEqCUnsigned
instance GHC.Classes.Ord [CTypes.CFloating] = CTypes.$fOrdCFloating
instance GHC.Classes.Ord [CTypes.CSigned] = CTypes.$fOrdCSigned
instance GHC.Classes.Ord [CTypes.CUnsigned] = CTypes.$fOrdCUnsigned
instance GHC.Show.Show [CTypes.CFloating] = CTypes.$fShowCFloating
instance GHC.Show.Show [CTypes.CSigned] = CTypes.$fShowCSigned
instance GHC.Show.Show [CTypes.CUnsigned] = CTypes.$fShowCUnsigned
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

