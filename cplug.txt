-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Recompile and run partially applied C functions in Haskell, during runtime
--   
--   Please see README.md
@package cplug
@version 0.2.0.0

module Parse.Types

module Data.Wrapped

-- | This is a wrapper type made specifically for <tt>Compilable</tt>
--   instances. <tt>a</tt> should be a functional type and <tt>b</tt> the
--   "last" return type of that function. In all instances, <tt>a</tt> is
--   considered a kind of metadata (as it should only be accessed by
--   compiling functions).
data Wrapped a b
Wrap :: a -> b -> Wrapped a b
defWrap :: Default a => b -> Wrapped a b

-- | Unwrap the function
unwrapF :: Wrapped a b -> a

-- | Unwrap the return value
unwrapR :: Wrapped a b -> b

-- | Synonym for <a>unwrapR</a>
unwrap :: Wrapped a b -> b

-- | <a>wrappedAp</a> or `wrapped function apply`
wrappedAp :: Wrapped (t -> a) b -> t -> Wrapped a b

-- | This note applies to all the instances for `Wrapped a b`: These
--   instances ignore <tt>a</tt>, unless it's required for the type, for
--   example with <a>Bounded</a>, in which case `a = Data.Default.def`
instance GHC.Classes.Eq b => GHC.Classes.Eq (Data.Wrapped.Wrapped a b)
instance GHC.Classes.Ord b => GHC.Classes.Ord (Data.Wrapped.Wrapped a b)
instance (Data.Default.Class.Default a, GHC.Enum.Enum b) => GHC.Enum.Enum (Data.Wrapped.Wrapped a b)
instance (Data.Default.Class.Default a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (Data.Wrapped.Wrapped a b)
instance GHC.Base.Functor (Data.Wrapped.Wrapped a)
instance Data.Default.Class.Default a => GHC.Base.Applicative (Data.Wrapped.Wrapped a)
instance (Data.Default.Class.Default a, Data.Default.Class.Default b) => Data.Default.Class.Default (Data.Wrapped.Wrapped a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Wrapped.Wrapped a b)

module Text.PrettyPrint.HughesPJ.Ext
instance TextShow.Classes.TextShow Text.PrettyPrint.HughesPJ.Doc
instance TextShow.Classes.TextShow Text.PrettyPrint.HughesPJ.TextDetails

module Data.Text.Aux

-- | <a>showInt</a> should be equivalent to `pack . show` for the
--   <a>Int</a> type, except a bit faster since it uses <tt>Text</tt>
--   library functions
showInt :: Int -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; textAp "Hello" "World"
--   "Hello (World)"
--   </pre>
textAp :: String -> Text -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; wrapText '|' "text"
--   "|text|"
--   </pre>
wrapText :: Char -> Text -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; addArrows . map T.pack ["Bool", "String", "Int"]
--   "Bool -&gt; String -&gt; Int"
--   </pre>
addArrows :: [Text] -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; unwords2 (T.pack "Hello") (T.pack "World")
--   "Hello World"
--   </pre>
unwords2 :: Text -> Text -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; appendAfter ", " "Hello" "World"
--   "Hello, World"
--   </pre>
appendAfter :: Text -> Text -> Text -> Text

-- | Add parentheses around a <tt>Text</tt> object
parens :: Text -> Text

-- | <a>wordLines</a> converts a Text input to a list of lists, where
--   `wordLines text !! i !! j` is the jth word of the ith line of
--   <tt>text</tt>.
wordLines :: Text -> [[Text]]

-- | See <a>wordLines</a>
unWordLines :: [[Text]] -> Text

-- | Shortcut for
--   
--   <pre>
--   unlines . map pack
--   </pre>
packUnlines :: [String] -> Text

-- | Shortcut for
--   
--   <pre>
--   unwords . map pack
--   </pre>
packUnwords :: [String] -> Text

-- | Convert a pretty-printable object to <tt>Text</tt>
prettyShowt :: Pretty p => p -> Text


-- | <i>Deprecated: All derivation should be covered by Class.hs</i>
module HSGen.Recompiler.Instances

-- | Example: `oneFix 13 = Text.pack "Fix a32"`
oneFix :: Int -> Text

-- | `fixes 3 == pack "Fix a3 -&gt; Fix a2 -&gt; Fix a1"`
fixes :: Int -> Text

-- | `makeFwr 2 == pack "Fix a2 -&gt; Fix a1 -&gt; Wrapped f r"`
makeFwr :: Int -> Text

-- | `makeFws 2 == pack "Fix a2 -&gt; Fix a1 -&gt; Wrapped g s"`
makeFws :: Int -> Text

-- | "Wrapped f r"
wr :: Text

-- | "Wrapped g s"
ws :: Text
makeXs :: Int -> Text
makeUnfixeds :: Int -> Text

-- | `makeLambdaXs 3 == pack "\x1 x2 x3 -&gt;"`
makeLambdaXs :: Int -> Text

-- | Generate the text for an instance of the class <tt>Compilable</tt>
--   with <tt>n</tt> arguments of the form `Fix ai`
genInstance :: Int -> Text

-- | Raw text used by <a>classText</a>
classStr :: [String]

-- | Text form of <tt>Compilable</tt>
classText :: Text

module Data.Fixable

-- | This is a analogue to <a>Maybe</a>, but without all of the predefined
--   instances, to prevent errors.
data Fix a
Unfixed :: Fix a
Fixed :: a -> Fix a

-- | Illustrative examples:
--   
--   <pre>
--   &gt;&gt;&gt; isFixed (Fixed "something")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isFixed Unfixed
--   False
--   </pre>
isFixed :: Fix a -> Bool

-- | <a>fromFixed</a> throws an error on <a>Unfixed</a>
fromFixed :: Fix a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Fixable.Fix a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Fixable.Fix a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Fixable.Fix a)

module HSGen.Recompiler.Class

-- | This class is of functions with type <tt>a</tt> and final return type
--   <tt>r</tt>. Additionally, <tt>r</tt> should be of the form:
--   <a>Wrapped</a> a b
class Resolvable a r | a -> r

-- | <a>resolve</a> resolves a "<a>Resolvable</a> a r" to <tt>r</tt>
resolve :: Resolvable a r => a -> r
class Compilable a r b s | a -> r, b -> s, a s -> b, r b -> a

-- | `($$$) f wrappedFunction` essentially applies <tt>f</tt> directly to
--   the <a>Wrapped</a> part of <tt>wrappedFunction</tt>.
($$$) :: Compilable a r b s => (r -> s) -> a -> b

-- | Given a simple <a>Compilable</a> function:
--   
--   <pre>
--   plus :: Int -&gt; Int -&gt; Wrapped (Int -&gt; Int -&gt; Int) Int
--   </pre>
--   
--   You can use `($$)` to apply <tt>plus</tt> to both the outer
--   (<a>Int</a> -&gt; <a>Int</a> -&gt; ..) and innner (<a>Wrapped</a>
--   (<a>Int</a> -&gt; ..)) functions of <tt>plus</tt>. For example:
--   
--   <pre>
--   &gt;&gt;&gt; plus $$ 1 $$ 2
--   Wrap 3 3
--   </pre>
($$) :: Compilable a1 (Wrapped (t -> a) b) t1 (Wrapped a b) => (t -> a1) -> t -> t1

-- | See <a>Resolvable</a>
class FixResolvable a r | a -> r
fixResolve :: FixResolvable a r => a -> r

-- | See <a>Compilable</a>
class FixCompilable a r b s | a -> r, b -> s, a s -> b, r b -> a
(###) :: FixCompilable a r b s => (r -> s) -> a -> b

-- | See `($$)`
(##) :: FixCompilable a (Wrapped (r -> a1) b) (r -> r1) (Wrapped a1 b) => a -> r -> r1

-- | Apply a function to a <a>Compilable</a> from the outside (just regular
--   application) and also inside (`($$$)`)
apInOut :: Compilable a b b c => (b -> c) -> a -> c

-- | See <a>apInOut</a>
fixApInOut :: FixCompilable a b b c => (b -> c) -> a -> c

-- | Flip a compilable function
flipC :: Compilable a1 (a -> b -> c) c (b -> a -> c) => (a -> b -> a1) -> b -> a -> c

-- | See <a>flipC</a>
fixFlipC :: FixCompilable a (a1 -> b -> c) (a1 -> b -> c) (b -> a1 -> c) => a -> b -> a1 -> c
replaceFW :: a -> Wrapped a b -> Wrapped a b

-- | Compile a compilable function, essentially by resolving to the wrapped
--   function and return value, unwrapping the non-compilable function
--   (i.e. getting the compiled version), and replacing the original
--   non-compilable function.
compile :: (Compilable a1 (Wrapped a b) r (Wrapped a b), Resolvable a1 (Wrapped a b1)) => a1 -> r

-- | See <a>compile</a>
fixCompile :: (Compilable a1 (Wrapped a b) r (Wrapped a b), Resolvable a1 (Wrapped a b1)) => a1 -> r
instance HSGen.Recompiler.Class.Resolvable (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped a b)
instance HSGen.Recompiler.Class.Resolvable a r => HSGen.Recompiler.Class.Resolvable (t -> a) r
instance HSGen.Recompiler.Class.Compilable (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped c d) (Data.Wrapped.Wrapped c d)
instance HSGen.Recompiler.Class.Compilable a r b s => HSGen.Recompiler.Class.Compilable (t -> a) r (t -> b) s
instance HSGen.Recompiler.Class.FixResolvable (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped a b)
instance HSGen.Recompiler.Class.FixResolvable a r => HSGen.Recompiler.Class.FixResolvable (Data.Fixable.Fix t -> a) r
instance HSGen.Recompiler.Class.FixCompilable (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped a b) (Data.Wrapped.Wrapped c d) (Data.Wrapped.Wrapped c d)
instance HSGen.Recompiler.Class.FixCompilable a r b s => HSGen.Recompiler.Class.FixCompilable (Data.Fixable.Fix t -> a) r (Data.Fixable.Fix t -> b) s

module HSGen

module Data.Either.Aux

-- | This provides safe unpacking of a <a>Left</a> object.
fromLeft :: Either a b -> Maybe a

-- | This provides safe unpacking of a <a>Right</a> object.
fromRight :: Either a b -> Maybe b

-- | This maps a function over a list, only applying it to <a>Left</a>
--   objects
mapLeft :: (t -> a) -> [Either t b] -> [Either a b]

-- | This maps a function over a list, only applying it to <a>Right</a>
--   objects
mapRight :: (t -> b) -> [Either a t] -> [Either a b]

-- | This will throw an error if its input is <a>Right</a>
unsafeFromLeft :: Either a b -> a

module CGen.Typed

-- | Adds <tt>U</tt> to the end of a <tt>Text</tt> object
addUnsigned :: Text -> Text

-- | Adds <tt>L</tt> to the end of a <tt>Text</tt> object
addLong :: Text -> Text
showt :: Show a => a -> Text

-- | This class allows one to <a>show</a> objects from
--   <a>Foreign.C.Types</a> in a way that won't throw warnings if used in C
--   code. For example, 'unsigned long long' literals need the <tt>ULL</tt>
--   annotation.
class CShow a
showForC :: CShow a => a -> Text
instance CGen.Typed.CShow Foreign.C.Types.CChar
instance CGen.Typed.CShow Foreign.C.Types.CShort
instance CGen.Typed.CShow Foreign.C.Types.CLong
instance CGen.Typed.CShow Foreign.C.Types.CPtrdiff
instance CGen.Typed.CShow Foreign.C.Types.CLLong
instance CGen.Typed.CShow Foreign.C.Types.CIntPtr
instance CGen.Typed.CShow Foreign.C.Types.CClock
instance CGen.Typed.CShow Foreign.C.Types.CFloat
instance CGen.Typed.CShow Foreign.C.Types.CSChar
instance CGen.Typed.CShow Foreign.C.Types.CUShort
instance CGen.Typed.CShow Foreign.C.Types.CULong
instance CGen.Typed.CShow Foreign.C.Types.CSize
instance CGen.Typed.CShow Foreign.C.Types.CULLong
instance CGen.Typed.CShow Foreign.C.Types.CUIntPtr
instance CGen.Typed.CShow Foreign.C.Types.CTime
instance CGen.Typed.CShow Foreign.C.Types.CDouble
instance CGen.Typed.CShow Foreign.C.Types.CUChar
instance CGen.Typed.CShow Foreign.C.Types.CInt
instance CGen.Typed.CShow Foreign.C.Types.CWchar
instance CGen.Typed.CShow Foreign.C.Types.CIntMax
instance CGen.Typed.CShow Foreign.C.Types.CUSeconds
instance CGen.Typed.CShow Foreign.C.Types.CUInt
instance CGen.Typed.CShow Foreign.C.Types.CSigAtomic
instance CGen.Typed.CShow Foreign.C.Types.CUIntMax
instance CGen.Typed.CShow Foreign.C.Types.CSUSeconds

module CGen

module Aux

-- | Converts a tuple to a list
tupToList :: (a, a) -> [a]

-- | Illustrative example:
--   
--   <pre>
--   &gt;&gt;&gt; lastTup [1,2,3,4]
--   ([1,2,3], 4)
--   </pre>
--   
--   Used to parse input vars, ex:
--   
--   <pre>
--   lastTup ["unsigned", "int", "x"] == Just (["unsigned", "int"], "x")
--   </pre>
lastTup :: [a] -> Maybe ([a], a)

-- | Applies a function to the first element of a tuple.
apFst :: (a1 -> a2) -> (a1, a) -> (a2, a)

-- | Apply the input function to the last element of the list
--   
--   <pre>
--   &gt;&gt;&gt; apToLast (const 0) [1,2,3,4]
--   [1,2,3,0]
--   </pre>
apToLast :: (a -> a) -> [a] -> [a]

module HSGen.FFI

-- | This is the standard language pragma for Haskell FFI
pragma :: Text

-- | This generates the import line for <a>Foreign.C.Types</a>
typesImport :: [Text] -> Text
tlist :: [Text]

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; ioifyUnit (T.pack "Bool")
--   "IO (Bool)"
--   </pre>
ioifyUnit :: Text -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; fixUnit (T.pack "String")
--   "Fix (String)"
--   </pre>
fixUnit :: Text -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; ioifyTypeList . map T.pack ["Bool", "String", "Int"]
--   ["Bool", "String", "IO (Int)"]
--   </pre>
ioifyTypeList :: [Text] -> [Text]

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; fixInit . map T.pack $ ["a", "b", "c"]
--   "Fix (a) -&gt; Fix (b)"
--   </pre>
fixInit :: [Text] -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; wrapperLast . map T.pack $ ["a", "b", "c"]
--   "Wrapper (FunPtr (a -&gt; b -&gt; c) (c))"
--   </pre>
wrapperLast :: [Text] -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; fixTypeList (T.pack "a -&gt; b -&gt; c")
--   "Fix (a) -&gt; Fix (b) -&gt; Wrapper (FunPtr (a -&gt; b -&gt; c)) c"
--   </pre>
fixTypeList :: [Text] -> Text

-- | Example:
--   
--   <pre>
--   &gt;&gt;&gt; functionImport (T.pack "math.h") (T.pack "sin") (T.pack "CDouble -&gt; CDouble")
--   "foreign import ccall \"math.h sin\" c_sin :: CDouble -&gt; CDouble \n"
--   </pre>
functionImport :: Text -> Text -> Text -> Text
defUnfix :: Default a => Fix a -> a
importBits :: Text
auxBoolToText :: Int -> Text
mkTup :: Int -> Text

-- | <i>Warning: This (generated) function needs a specific type
--   declaration, don't forget to implement!</i>
mkBoolToCUInt :: Int -> Text
mkBoolToCUIntName :: Int -> Text
andIsFixed :: Int -> Text
mkIsFixed :: Int -> Text
mkIsFixedName :: Int -> Text
instance Data.Bits.Bits a => Data.Default.Class.Default a

module Parse.Templates
data NamedVar
NameVar :: Text -> Text -> NamedVar
[varType] :: NamedVar -> Text
[varName] :: NamedVar -> Text
data CFunctionTemplate
CFunTempl :: Text -> Text -> [NamedVar] -> Text -> CFunctionTemplate
[returnType] :: CFunctionTemplate -> Text
[functionName] :: CFunctionTemplate -> Text
[inputVars] :: CFunctionTemplate -> [NamedVar]
[functionBody] :: CFunctionTemplate -> Text
data NamedVal a
NameVal :: Text -> a -> NamedVal a
[valName] :: NamedVal a -> Text
[value] :: NamedVal a -> a
unTemplate :: CFunctionTemplate -> Text
fetchVar :: NamedVal a -> [NamedVar] -> (Maybe NamedVar, [NamedVar])

-- | Converts a <a>NamedVar</a> to a dummy variable, e.g. <tt>int x</tt> to
--   <tt>int dummy_x</tt>
dumifyNamedVar :: NamedVar -> NamedVar
updateInputVar :: NamedVal a -> CFunctionTemplate -> [(Text, Text)]
insertAfterNewline :: Text -> Text -> Text
namedVarDeclaration :: (CShow a, CTypeable a) => NamedVal a -> Text
declareNamedVar :: (CShow a, CTypeable a) => CFunctionTemplate -> NamedVal a -> Text
update :: (a -> Maybe a) -> a -> a
cTypeRep :: Text -> TypeRep
class Typeable a => CTypeable a
toCType :: CTypeable a => a -> Text

-- | Pseudocode illustrative example:
--   
--   <pre>
--   toPtrTypeRep Int == Ptr Int
--   </pre>
toPtrTypeRep :: TypeRep -> TypeRep

-- | See <a>toPtrTypeRep</a>
toFunPtrTypeRep :: TypeRep -> TypeRep

-- | Get the <a>TyCon</a> type of the first argument and apply it to the
--   <a>TypeRep</a> of the second
applyTypeRep :: Typeable a => a -> TypeRep -> TypeRep

-- | Analogous to `(:)` for lists, where the element is a <a>TyCon</a> and
--   the list is a <a>TypeRep</a>
typeRepCons :: TyCon -> TypeRep -> TypeRep

-- | Get the <a>head</a> of a type, e.g.
--   
--   <pre>
--   &gt;&gt;&gt; `typeRepHead (undefined :: IO Int)
--   IO
--   </pre>
typeConHead :: Typeable a => a -> TyCon
instance GHC.Generics.Selector Parse.Templates.S1_0_1NamedVal
instance GHC.Generics.Selector Parse.Templates.S1_0_0NamedVal
instance GHC.Generics.Constructor Parse.Templates.C1_0NamedVal
instance GHC.Generics.Datatype Parse.Templates.D1NamedVal
instance GHC.Generics.Selector Parse.Templates.S1_0_3CFunctionTemplate
instance GHC.Generics.Selector Parse.Templates.S1_0_2CFunctionTemplate
instance GHC.Generics.Selector Parse.Templates.S1_0_1CFunctionTemplate
instance GHC.Generics.Selector Parse.Templates.S1_0_0CFunctionTemplate
instance GHC.Generics.Constructor Parse.Templates.C1_0CFunctionTemplate
instance GHC.Generics.Datatype Parse.Templates.D1CFunctionTemplate
instance GHC.Generics.Selector Parse.Templates.S1_0_1NamedVar
instance GHC.Generics.Selector Parse.Templates.S1_0_0NamedVar
instance GHC.Generics.Constructor Parse.Templates.C1_0NamedVar
instance GHC.Generics.Datatype Parse.Templates.D1NamedVar
instance GHC.Show.Show a => GHC.Show.Show (Parse.Templates.NamedVal a)
instance GHC.Generics.Generic (Parse.Templates.NamedVal a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Parse.Templates.NamedVal a)
instance GHC.Show.Show Parse.Templates.CFunctionTemplate
instance GHC.Generics.Generic Parse.Templates.CFunctionTemplate
instance GHC.Classes.Eq Parse.Templates.CFunctionTemplate
instance GHC.Show.Show Parse.Templates.NamedVar
instance GHC.Generics.Generic Parse.Templates.NamedVar
instance GHC.Classes.Eq Parse.Templates.NamedVar
instance TextShow.Classes.TextShow Parse.Templates.NamedVar
instance TextShow.Classes.TextShow Parse.Templates.CFunctionTemplate
instance TextShow.Classes.TextShow a => TextShow.Classes.TextShow (Parse.Templates.NamedVal a)

module Parse

-- | Parse a '.c' file
parse :: FilePath -> IO (Maybe CTranslUnit)

-- | <a>parse</a>, but with debug information
debugParse :: Bool -> FilePath -> IO (Maybe CTranslUnit)

-- | make function templates from a '.c' file
parseFunctions :: FilePath -> IO [CFunctionTemplate]

-- | (For debugging) Print the <a>CFunctionTemplate</a>s parsed from a file
printParsedFunctions :: FilePath -> IO ()
fstCTranslUnit :: CTranslationUnit t -> [CExternalDeclaration t]
isCFDefExt :: CExternalDeclaration t -> Bool
fromCFDefExt :: CExternalDeclaration t -> Maybe (CFunctionDef t)
justFunctions :: [CExternalDeclaration t] -> [CFunctionDef t]
eitherCFDefExt :: CExternalDeclaration t -> Either (CFunctionDef t) (CExternalDeclaration t)

-- | `CFunDef [CDeclarationSpecifier a] (CDeclarator a) [CDeclaration a]
--   (CStatement a) a` &gt; CFunDef &gt; [CDeclarationSpecifier a] -- type
--   specifier and qualifier &gt; (CDeclarator a) -- declarator &gt;
--   [CDeclaration a] -- optional declaration list &gt; (CStatement a) --
--   compound statement a
fTypeSpec :: CFunctionDef t -> [CDeclarationSpecifier t]
fDecl :: CFunctionDef t -> CDeclarator t
fOptDecl :: CFunctionDef t -> [CDeclaration t]
fStatement :: CFunctionDef t -> CStatement t
fRest :: CFunctionDef t -> t

-- | <a>decIdent</a> and following are simple unpackers for a datatype from
--   Language.C that I wish used record syntax. `CDeclr (Maybe Ident)
--   [CDerivedDeclarator a] (Maybe (CStringLiteral a)) [CAttribute a] a`
decIdent :: CDeclarator t -> Maybe Ident
decDerivedDecls :: CDeclarator t -> [CDerivedDeclarator t]
decStrLit :: CDeclarator t -> Maybe (CStringLiteral t)
decAttributes :: CDeclarator t -> [CAttribute t]
decRest :: CDeclarator t -> t
derivedDeclaratorFunDecl :: CDerivedDeclarator t -> Maybe (Either [Ident] ([CDeclaration t], Bool))
derivedDeclaratorFunAttrs :: CDerivedDeclarator t -> Maybe [CAttribute t]
derivedDeclaratorFunRest :: CDerivedDeclarator a -> Maybe a
unpackIdent :: Ident -> String

-- | This converts a typed C variable to (type, name), e.g. `"unsigned int
--   x" -&gt; Just ("unsigned int", "x")`. (Returns nothing on empty
--   string.)
splitTypedVar :: Text -> Maybe (Text, Text)
splitToNamedVar :: (Text, Text) -> NamedVar
makeNamedVar :: Text -> Maybe NamedVar
getFunctionName :: CExternalDeclaration t -> Maybe Ident
getFunctionNameText :: CExternalDeclaration t -> Maybe Text
getFunctionReturnType :: Pretty (CDeclarationSpecifier t) => CExternalDeclaration t -> Maybe [String]
getFunctionReturnTypeText :: Pretty (CDeclarationSpecifier t) => CExternalDeclaration t -> Maybe Text
getFunctionInputTypes :: CExternalDeclaration t -> Maybe [CDeclaration t]
getFunctionInputTypesText :: Pretty (CDeclaration t) => CExternalDeclaration t -> Maybe [NamedVar]
getFunctionBody :: CExternalDeclaration t -> Maybe (CStatement t)
getFunctionBodyText :: Pretty (CStatement t) => CExternalDeclaration t -> Maybe Text
mkCFunTempl :: (Pretty (CStatement t), Pretty (CDeclarationSpecifier t), Pretty (CDeclaration t)) => CExternalDeclaration t -> Maybe CFunctionTemplate
mkCFunTempls :: (Monad m, Pretty (CStatement t), Pretty (CDeclarationSpecifier t), Pretty (CDeclaration t)) => m (Maybe [CExternalDeclaration t]) -> m [CFunctionTemplate]
